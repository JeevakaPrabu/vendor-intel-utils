From 00c6f7d3cad09cbf86d88499ea4921313ccae9a3 Mon Sep 17 00:00:00 2001
From: "Singh, Sapna1" <sapna1.singh@intel.com>
Date: Fri, 14 Jul 2023 15:55:31 +0530
Subject: [PATCH] Fix for static analysis issues

Changes include:
- Initialize the uninitialized varibles.
- Fix for Memory leak by releasing the allocated memory.
- Add check for self assign issue
- Typecast the variables to appropriate type.
- Fix for unused return values by adding a check for returned value.
- Fix for unreachable code by removing unnecessary checks.
- Fix for buffer overflow issue by limiting the size of dst buffer as
minimum of the two(src and dst buffer).
- Fix for vaMapBuffer unchecked return value
- Add copy constructor, assignment operator an destructor
to be complaint with three/five/zero rule.

Change-Id: Ibde73107bfa5658230ebb42846dc0651fba31aa4
Tracked-On: OAM-111171
Tracked-On: OAM-111598
Signed-off-by: Singh, Sapna1 <sapna1.singh@intel.com>
Signed-off-by: Badrappan, Jeevaka <jeevaka.badrappan@intel.com>
---
 omx_buffers/src/mfx_omx_srf_ibuf.cpp          |  4 +-
 omx_components/src/mfx_omx_vdec_component.cpp |  9 +++--
 omx_components/src/mfx_omx_venc_component.cpp | 23 +++++++-----
 omx_components/src/mfx_omx_vpp_wrapp.cpp      |  1 +
 omx_core/src/mfx_omx_core.cpp                 | 17 +++++++--
 omx_utils/include/mfx_omx_types.h             | 37 +++++++++++--------
 .../include/spl/mfx_omx_hevc_structures.h     |  7 ++++
 omx_utils/src/mfx_omx_utils.cpp               |  6 ++-
 omx_utils/src/mfx_omx_vaapi_allocator.cpp     | 17 +++------
 9 files changed, 74 insertions(+), 47 deletions(-)

diff --git a/omx_buffers/src/mfx_omx_srf_ibuf.cpp b/omx_buffers/src/mfx_omx_srf_ibuf.cpp
index 92d303c..09a0fb1 100755
--- a/omx_buffers/src/mfx_omx_srf_ibuf.cpp
+++ b/omx_buffers/src/mfx_omx_srf_ibuf.cpp
@@ -180,7 +180,7 @@ mfxStatus MfxOmxInputSurfacesPool::PrepareSurface(OMX_BUFFERHEADERTYPE* pBuffer)
             switch(m_MfxFramesInfo.FourCC)
             {
                 case MFX_FOURCC_NV12:
-                    pVideo16 = (mfxU8*)calloc(3*nPitch*m_MfxFramesInfo.Height/2, sizeof(mfxU8));
+                    pVideo16 = (mfxU8*)calloc((3*(mfxU32)(nPitch * m_MfxFramesInfo.Height))/2, sizeof(mfxU8));
                     if (pVideo16)
                     {
                         pBufInfo->sSurface.Data.Y = pVideo16;
@@ -190,7 +190,7 @@ mfxStatus MfxOmxInputSurfacesPool::PrepareSurface(OMX_BUFFERHEADERTYPE* pBuffer)
                     else mfx_res = MFX_ERR_MEMORY_ALLOC;
                     break;
                 case MFX_FOURCC_YUY2:
-                    pVideo16 = (mfxU8*)calloc(2*nPitch*m_MfxFramesInfo.Height, sizeof(mfxU8));
+                    pVideo16 = (mfxU8*)calloc(2 * (mfxU32)(nPitch * m_MfxFramesInfo.Height), sizeof(mfxU8));
                     if (pVideo16)
                     {
                         pBufInfo->sSurface.Data.Y = pVideo16;
diff --git a/omx_components/src/mfx_omx_vdec_component.cpp b/omx_components/src/mfx_omx_vdec_component.cpp
index f3e02ec..9586385 100644
--- a/omx_components/src/mfx_omx_vdec_component.cpp
+++ b/omx_components/src/mfx_omx_vdec_component.cpp
@@ -170,7 +170,7 @@ OMX_ERRORTYPE MfxOmxVdecComponent::Init(void)
         Reset();
 
         mfxConfig cfg[2];
-        mfxVariant cfgVal[2];
+        mfxVariant cfgVal[2] = {};
 
         m_Loader = MFXLoad();
         if (nullptr == m_Loader) {
@@ -1513,8 +1513,8 @@ OMX_ERRORTYPE MfxOmxVdecComponent::GetConfig(
                 {
                     omx_res = OMX_ErrorUnsupportedSetting;
                 }
-
-                omx_res = OMX_ErrorNone;
+                else
+                    omx_res = OMX_ErrorNone;
                 break;
             }
 #ifdef HEVC10HDR_SUPPORT
@@ -2313,7 +2313,8 @@ void MfxOmxVdecComponent::MainThread(void)
                             if (pWorkSurface)
                             {
                                 mfx_sts = m_pSurfaces->QueueBufferForSending(pWorkSurface, NULL);
-
+                                if (MFX_ERR_NONE == mfx_sts)
+                                    MFX_OMX_AUTO_TRACE("Queueing Buffers for Sending");
                                 m_bEosHandlingFinished = true;
 
                                 m_pAsyncSemaphore->Post();
diff --git a/omx_components/src/mfx_omx_venc_component.cpp b/omx_components/src/mfx_omx_venc_component.cpp
index d915c16..0c6f423 100755
--- a/omx_components/src/mfx_omx_venc_component.cpp
+++ b/omx_components/src/mfx_omx_venc_component.cpp
@@ -159,7 +159,7 @@ OMX_ERRORTYPE MfxOmxVencComponent::Init(void)
         // prepare Media SDK
 #ifdef USE_ONEVPL
         mfxConfig cfg[2];
-        mfxVariant cfgVal[2];
+        mfxVariant cfgVal[2] = {};
 
         m_Loader = MFXLoad();
         if (nullptr == m_Loader) {
@@ -1312,6 +1312,8 @@ OMX_ERRORTYPE MfxOmxVencComponent::DealWithBuffer(
             }
             *ppBufferHdr = pBufferHeader;
         }
+        else
+            MFX_OMX_FREE(pBufferHeader);
     }
     MFX_OMX_AUTO_TRACE_U32(omx_res);
     return omx_res;
@@ -1787,9 +1789,9 @@ OMX_ERRORTYPE MfxOmxVencComponent::SetParameter(
                         MFX_OMX_AUTO_TRACE_I32(pParam->bStoreMetaData);
                         {
 #ifdef USE_ONEVPL
-                            m_MfxVideoParams.IOPattern &= !(MFX_IOPATTERN_IN_VIDEO_MEMORY | MFX_IOPATTERN_IN_SYSTEM_MEMORY);
+                            m_MfxVideoParams.IOPattern &= ~(MFX_IOPATTERN_IN_VIDEO_MEMORY | MFX_IOPATTERN_IN_SYSTEM_MEMORY);
 #else
-                            m_MfxVideoParams.IOPattern &= !(MFX_IOPATTERN_IN_VIDEO_MEMORY | MFX_IOPATTERN_IN_SYSTEM_MEMORY | MFX_IOPATTERN_IN_OPAQUE_MEMORY);
+                            m_MfxVideoParams.IOPattern &= ~(MFX_IOPATTERN_IN_VIDEO_MEMORY | MFX_IOPATTERN_IN_SYSTEM_MEMORY | MFX_IOPATTERN_IN_OPAQUE_MEMORY);
 #endif
                             m_MfxVideoParams.IOPattern |= pParam->bStoreMetaData ? MFX_IOPATTERN_IN_VIDEO_MEMORY : MFX_IOPATTERN_IN_SYSTEM_MEMORY;
 
@@ -2029,8 +2031,8 @@ OMX_ERRORTYPE MfxOmxVencComponent::GetBlackFrame(OMX_VIDEO_INTEL_REQUEST_BALCK_F
 
         if (MFX_ERR_NONE == mfx_res)
         {
-            memset(data.Y, 0x0, data.Pitch * m_MfxVideoParams.mfx.FrameInfo.Height);
-            memset(data.U, 0x80, data.Pitch * m_MfxVideoParams.mfx.FrameInfo.Height / 2);
+            memset(data.Y, 0x0, (mfxU64)data.Pitch * m_MfxVideoParams.mfx.FrameInfo.Height);
+            memset(data.U, 0x80, (mfxU64)data.Pitch * m_MfxVideoParams.mfx.FrameInfo.Height / 2);
             mfx_res = gralloc->UnlockFrame(handle, &data);
 
             m_pSurfaces->SetBlackFrame(handle);
@@ -2536,6 +2538,8 @@ void MfxOmxVencComponent::MainThread(void)
             {
                 MFX_OMX_AUTO_TRACE("handling EOS");
                 mfx_sts = ProcessEOS();
+                if (MFX_ERR_NONE == mfx_sts)
+                    MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "MainThread : No Error in handling EOS");
                 // If error happened at the end of stream we skip this
             }
         }
@@ -2624,9 +2628,10 @@ mfxStatus MfxOmxVencComponent::ProcessEOS(void)
 
             m_pAsyncSemaphore->Post();
         }
-        else m_bCanNotProcess = true;
-
-        mfx_res = MFX_ERR_NONE;
+        else {
+            m_bCanNotProcess = true;
+            mfx_res = MFX_ERR_NONE;
+        }
     }
     MFX_OMX_AUTO_TRACE_I32(m_bEosHandlingStarted);
     MFX_OMX_AUTO_TRACE_I32(m_bEosHandlingFinished);
@@ -3229,7 +3234,7 @@ void MfxOmxVencComponent::SkipFrame(void)
             m_lCurTargetBitrate = m_MfxVideoParams.mfx.TargetKbps * 1000;
             MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "[SkipFrameLog] ###Target bitrate change.###");
         }
-        mfxI64 avgFrameSize = m_MfxVideoParams.mfx.TargetKbps * 1000 * m_MfxVideoParams.mfx.FrameInfo.FrameRateExtD / m_MfxVideoParams.mfx.FrameInfo.FrameRateExtN;
+        mfxI64 avgFrameSize = (mfxI64)(m_MfxVideoParams.mfx.TargetKbps * 1000) * m_MfxVideoParams.mfx.FrameInfo.FrameRateExtD / m_MfxVideoParams.mfx.FrameInfo.FrameRateExtN;
         m_lBufferFullness += pAddBufInfo2->sBitstream.DataLength * 8 - avgFrameSize;
 
         mfxI64 overFlowBound = 0.8 * m_MfxVideoParams.mfx.TargetKbps * 1000;
diff --git a/omx_components/src/mfx_omx_vpp_wrapp.cpp b/omx_components/src/mfx_omx_vpp_wrapp.cpp
index 4ebe9e1..68ee14b 100644
--- a/omx_components/src/mfx_omx_vpp_wrapp.cpp
+++ b/omx_components/src/mfx_omx_vpp_wrapp.cpp
@@ -46,6 +46,7 @@ MfxOmxVppWrapp::MfxOmxVppWrapp(void):
     MFX_OMX_ZERO_MEMORY(m_vppParam);
     MFX_OMX_ZERO_MEMORY(m_allocator);
     MFX_OMX_ZERO_MEMORY(m_responses);
+    MFX_OMX_ZERO_MEMORY(m_vppSrf);
 }
 
 /*------------------------------------------------------------------------------*/
diff --git a/omx_core/src/mfx_omx_core.cpp b/omx_core/src/mfx_omx_core.cpp
index 8de5c43..e7e64df 100644
--- a/omx_core/src/mfx_omx_core.cpp
+++ b/omx_core/src/mfx_omx_core.cpp
@@ -323,9 +323,20 @@ static OMX_ERRORTYPE mfx_omx_read_config_file(void)
             if (components)
             {
                 g_ComponentsRegistry = components;
-
-                strcpy(g_ComponentsRegistry[g_ComponentsRegistryNum].m_component_name, name);
-                strcpy(g_ComponentsRegistry[g_ComponentsRegistryNum].m_component_so, value);
+                size_t name_max_len =
+                    sizeof(g_ComponentsRegistry[g_ComponentsRegistryNum].m_component_name) - 1;
+                size_t so_max_len =
+                    sizeof(g_ComponentsRegistry[g_ComponentsRegistryNum].m_component_so) - 1;
+
+                memset(g_ComponentsRegistry[g_ComponentsRegistryNum].m_component_name, 0,
+                       sizeof(g_ComponentsRegistry[g_ComponentsRegistryNum].m_component_name));
+                memset(g_ComponentsRegistry[g_ComponentsRegistryNum].m_component_so, 0,
+                       sizeof(g_ComponentsRegistry[g_ComponentsRegistryNum].m_component_so));
+
+                strncpy(g_ComponentsRegistry[g_ComponentsRegistryNum].m_component_name, name,
+                      std::min(name_max_len, strlen(name)));
+                strncpy(g_ComponentsRegistry[g_ComponentsRegistryNum].m_component_so, value,
+                      std::min(so_max_len, strlen(value)));
                 g_ComponentsRegistry[g_ComponentsRegistryNum].m_component_flags =
                     (str_flags)? strtol(str_flags, NULL, 16): (OMX_U32)MFX_OMX_COMPONENT_FLAGS_NONE;
 
diff --git a/omx_utils/include/mfx_omx_types.h b/omx_utils/include/mfx_omx_types.h
index 4d1b867..d929d62 100644
--- a/omx_utils/include/mfx_omx_types.h
+++ b/omx_utils/include/mfx_omx_types.h
@@ -213,28 +213,33 @@ struct MfxOmxParamsWrapper: public T
             ext_buf_ptrs[i] = (mfxExtBuffer*)&ext_buf[i];
         }
     }
+
+    ~MfxOmxParamsWrapper() {
+    }
+
     MfxOmxParamsWrapper(const MfxOmxParamsWrapper& ref)
     {
         *this = ref; // call to operator=
     }
     MfxOmxParamsWrapper& operator=(const MfxOmxParamsWrapper& ref)
     {
-        T* dst = this;
-        const T* src = &ref;
-
-        *dst = *src;
-        payload = ref.payload;
-        if (!N) return *this;
-
-        MFX_OMX_ZERO_MEMORY(ext_buf_ptrs);
-        std::copy(std::begin(ref.ext_buf), std::end(ref.ext_buf), std::begin(ext_buf));
-        std::copy(std::begin(ref.ext_buf_idxmap), std::end(ref.ext_buf_idxmap), std::begin(ext_buf_idxmap));
-
-        this->ExtParam = ext_buf_ptrs;
-        for (size_t i = 0; i < N; ++i)
-        {
-            ext_buf_ptrs[i] = (mfxExtBuffer*)&ext_buf[i];
-        }
+	if (this != &ref) {
+            T* dst = this;
+            const T* src = &ref;
+
+            *dst = *src;
+            payload = ref.payload;
+            if (!N) return *this;
+
+            MFX_OMX_ZERO_MEMORY(ext_buf_ptrs);
+            std::copy(std::begin(ref.ext_buf), std::end(ref.ext_buf), std::begin(ext_buf));
+            std::copy(std::begin(ref.ext_buf_idxmap), std::end(ref.ext_buf_idxmap), std::begin(ext_buf_idxmap));
+            this->ExtParam = ext_buf_ptrs;
+            for (size_t i = 0; i < N; ++i)
+            {
+                ext_buf_ptrs[i] = (mfxExtBuffer*)&ext_buf[i];
+            }
+	}
         return *this;
     }
     MfxOmxParamsWrapper(const T& ref)
diff --git a/omx_utils/include/spl/mfx_omx_hevc_structures.h b/omx_utils/include/spl/mfx_omx_hevc_structures.h
index e6f05f2..87a4b2c 100644
--- a/omx_utils/include/spl/mfx_omx_hevc_structures.h
+++ b/omx_utils/include/spl/mfx_omx_hevc_structures.h
@@ -244,6 +244,13 @@ public:
             destroy();
     }
 
+    H265ScalingList(const H265ScalingList& refList) { this->m_initialized = refList.m_initialized; }
+    H265ScalingList & operator=(const H265ScalingList& refList)
+    {
+        this->m_initialized = refList.m_initialized;
+        return *this;
+    }
+
     int*      getScalingListAddress   (unsigned sizeId, unsigned listId)          { return m_scalingListCoef[sizeId][listId]; }
     const int* getScalingListAddress  (unsigned sizeId, unsigned listId) const    { return m_scalingListCoef[sizeId][listId]; }
     void     setRefMatrixId           (unsigned sizeId, unsigned listId, unsigned u)   { m_refMatrixId[sizeId][listId] = u; }
diff --git a/omx_utils/src/mfx_omx_utils.cpp b/omx_utils/src/mfx_omx_utils.cpp
index 87a525c..b3e1d47 100644
--- a/omx_utils/src/mfx_omx_utils.cpp
+++ b/omx_utils/src/mfx_omx_utils.cpp
@@ -480,11 +480,13 @@ mfxU32 GetBufferSize(mfxVideoParam const & par)
             maxKbps * DEFAULT_CPB_IN_SECONDS);
 
         bufferSize = !IsHRDBasedBRCMethod(par.mfx.RateControlMethod)
-            ? mfxU32(MFX_OMX_MIN(UINT_MAX, par.mfx.FrameInfo.Width * par.mfx.FrameInfo.Height * 3 / 2))
+            //? mfxU32(MFX_OMX_MIN(UINT_MAX, par.mfx.FrameInfo.Width * par.mfx.FrameInfo.Height * 3 / 2))
+            ? mfxU32(par.mfx.FrameInfo.Width * par.mfx.FrameInfo.Height * 3 / 2)
             : bufferSizeInBits / 8;
     }
     else
-        bufferSize = mfxU32(MFX_OMX_MIN(UINT_MAX, par.mfx.FrameInfo.Width * par.mfx.FrameInfo.Height * 3 / 2));
+        //bufferSize = mfxU32(MFX_OMX_MIN(UINT_MAX, par.mfx.FrameInfo.Width * par.mfx.FrameInfo.Height * 3 / 2));
+        bufferSize = mfxU32(par.mfx.FrameInfo.Width * par.mfx.FrameInfo.Height * 3 / 2);
 
     return bufferSize;
 }
diff --git a/omx_utils/src/mfx_omx_vaapi_allocator.cpp b/omx_utils/src/mfx_omx_vaapi_allocator.cpp
index 5fae460..0938dcb 100644
--- a/omx_utils/src/mfx_omx_vaapi_allocator.cpp
+++ b/omx_utils/src/mfx_omx_vaapi_allocator.cpp
@@ -277,10 +277,7 @@ mfxStatus MfxOmxVaapiFrameAllocator::RegisterSurface(VASurfaceID surface, mfxMem
                 pmid->m_bUseBufferDirectly = bUseBufferDirectly;
                 out_mid = pmid;
                 m_extMIDs.push_back(pmid);
-                if (out_mid)
-                    *mid = out_mid;
-                else
-                    mfx_res = MFX_ERR_UNKNOWN;
+                *mid = out_mid;
             }
             else mfx_res = MFX_ERR_NULL_PTR;
             return mfx_res;
@@ -808,7 +805,7 @@ mfxStatus MfxOmxVaapiFrameAllocator::AllocImpl(mfxFrameAllocRequest *request, mf
             else
             {
                 VAContextID context_id = request->AllocId;
-                mfxU32 codedbuf_size = (request->Info.Width * request->Info.Height) * 400LL / (16 * 16);
+                mfxU32 codedbuf_size = ((mfxU32)(request->Info.Width * request->Info.Height))* 400UL / (16 * 16);
 
                 for (numAllocated = 0; numAllocated < surfaces_num; numAllocated++)
                 {
@@ -846,11 +843,7 @@ mfxStatus MfxOmxVaapiFrameAllocator::AllocImpl(mfxFrameAllocRequest *request, mf
         {
             response->mids = NULL;
             response->NumFrameActual = 0;
-            if (VA_FOURCC_P208 != va_fourcc)
-            {
-                if (bCreateSrfSucceeded) vaDestroySurfaces(m_dpy, surfaces, surfaces_num);
-            }
-            else
+            if (VA_FOURCC_P208 == va_fourcc)
             {
                 for (i = 0; i < numAllocated; i++)
                     vaDestroyBuffer(m_dpy, surfaces[i]);
@@ -1147,7 +1140,9 @@ void MfxOmxVaapiFrameAllocator::upload_yuv_to_surface(unsigned char *newImageBuf
     int y_size = picture_width * picture_height;
     int u_size = (picture_width >> 1) * (picture_height >> 1);
 
-    vaMapBuffer(m_dpy, surface_image.buf, &surface_p);
+    va_status = vaMapBuffer(m_dpy, surface_image.buf, &surface_p);
+    if (va_status != VA_STATUS_SUCCESS) return;
+
     y_src = newImageBuffer;
     u_src = newImageBuffer + y_size; /* UV offset for NV12 */
     v_src = newImageBuffer + y_size + u_size;
-- 
2.40.0

