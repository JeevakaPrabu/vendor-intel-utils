From fd339f1aeea711ed6a6530b2610489c2813649fc Mon Sep 17 00:00:00 2001
From: Hongcheng Xie <hongcheng.xie@intel.com>
Date: Thu, 3 Sep 2020 10:43:06 +0800
Subject: [PATCH] Ueventd optimization in Android init

Moved from android-entry
1. Get rid of '-l server' parameters for android-entry
2. Reuse jsoncpp to avoid SDL problem
3. Support adding folder with multiple devices W/A recursively.

Change-Id: Ic8c09475279ea4320832b2f881cd94e5efc2a4ef
Signed-off-by: Fengqian Gao <fegnqian.gao@intel.com>
Signed-off-by: Liang Wang <liang.wang@intel.com>
Signed-off-by: Hongcheng Xie <hongcheng.xie@intel.com>
---
 init/Android.bp           |   2 +
 init/Android.mk           |   2 +
 init/coldboot_opt.cpp     | 314 ++++++++++++++++++++++++++++++++++++++
 init/coldboot_opt.h       |  13 ++
 init/first_stage_init.cpp |  10 ++
 5 files changed, 341 insertions(+)
 create mode 100644 init/coldboot_opt.cpp
 create mode 100644 init/coldboot_opt.h

diff --git a/init/Android.bp b/init/Android.bp
index 4865694f3..13c306a5a 100644
--- a/init/Android.bp
+++ b/init/Android.bp
@@ -40,6 +40,7 @@ init_device_sources = [
     "bootchart.cpp",
     "builtins.cpp",
     "devices.cpp",
+    "coldboot_opt.cpp",
     "firmware_handler.cpp",
     "first_stage_console.cpp",
     "first_stage_init.cpp",
@@ -173,6 +174,7 @@ cc_library_static {
         type: "lite",
         export_proto_headers: true,
     },
+    include_dirs: ["external/jsoncpp/include"],
 
     target: {
         recovery: {
diff --git a/init/Android.mk b/init/Android.mk
index 416b732d8..9c936140d 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -50,6 +50,7 @@ LOCAL_CPPFLAGS := $(init_cflags)
 LOCAL_SRC_FILES := \
     block_dev_initializer.cpp \
     devices.cpp \
+    coldboot_opt.cpp    \
     first_stage_console.cpp \
     first_stage_init.cpp \
     first_stage_main.cpp \
@@ -113,6 +114,7 @@ LOCAL_STATIC_LIBRARIES := \
     libext2_uuid \
     libprotobuf-cpp-lite \
     libsnapshot_init \
+	libjsoncpp \
 
 LOCAL_SANITIZE := signed-integer-overflow
 # First stage init is weird: it may start without stdout/stderr, and no /proc.
diff --git a/init/coldboot_opt.cpp b/init/coldboot_opt.cpp
new file mode 100644
index 000000000..13048cb62
--- /dev/null
+++ b/init/coldboot_opt.cpp
@@ -0,0 +1,314 @@
+#include <fstream>
+#include <iostream>
+#include <sstream>
+#include <string>
+#include <vector>
+#include <errno.h>
+#include <android-base/logging.h>
+
+#include <linux/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mount.h>
+#include <sys/statfs.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <sys/sysmacros.h>
+#include <json/json.h>
+
+#define COLDBOOT_DONE "/dev/.coldboot_done"
+
+namespace android {
+namespace init {
+
+struct DeviceInfo {
+
+    std::string dev_path;
+    mode_t type;
+    mode_t mode;
+    int major;
+    int minor;
+};
+
+std::map<std::string, mode_t> d_mapDeviceType = {
+    {"b", S_IFBLK}, {"c", S_IFCHR}
+};
+
+
+class ColdbootOpt {
+
+    public:
+        ColdbootOpt(const std::string& filepath, int id) {
+            std::ifstream _file(filepath);
+            _file >> jsonroot;
+            _file.close();
+            container_id = id;
+        }
+
+        void CreateDevices();
+
+    private:
+        int container_id;
+        Json::Value jsonroot;
+        std::vector<DeviceInfo> _devices;
+        std::vector<std::string> _subfolders;
+
+        void ParseCommonDeviceInfo();
+        void ParseDynamicDeviceInfo();
+        void ParseInputDeviceInfo();
+        void ParseDevicesInFolder();
+        void ParseDevicesInFolder(const std::string& folder, bool recursive, mode_t mode);
+        void UseHostDevNumber(DeviceInfo &device);
+        void RemountDev();
+
+};
+
+void ColdbootOpt::ParseCommonDeviceInfo() {
+
+    Json::Value devices_json = jsonroot["Devices"];
+    for(unsigned int index = 0; index < devices_json.size(); index ++) {
+        DeviceInfo _tmp;
+        _tmp.dev_path = devices_json[index]["path"].asString();
+        _tmp.major = devices_json[index]["major"].asInt();
+        _tmp.minor = devices_json[index]["minor"].asInt();
+        _tmp.mode = devices_json[index]["mode"].asInt();
+        _tmp.type = d_mapDeviceType[devices_json[index]["type"].asString()];
+
+        if((_tmp.major == 0) || (_tmp.minor == 0))
+            UseHostDevNumber(_tmp);
+        _devices.push_back(_tmp);
+    }
+}
+
+void ColdbootOpt::ParseDevicesInFolder(const std::string& folder, bool recursive, mode_t mode) {
+    DIR *dir;
+    struct dirent *dir_ptr;
+    std::string full_path;
+
+    if((dir = opendir(folder.c_str())) == NULL)
+        return;
+
+    _subfolders.push_back(folder);
+
+    while((dir_ptr = readdir(dir)) != NULL) {
+       if(dir_ptr->d_name[0] == '.')
+           continue;
+       if(dir_ptr->d_type == DT_BLK || dir_ptr->d_type == DT_CHR) {
+           struct stat buf;
+           DeviceInfo _tmp;
+           full_path = folder + "/" + std::string(dir_ptr->d_name);
+           if(stat(full_path.c_str(), &buf) != 0)
+               continue;
+
+           _tmp.dev_path = full_path;
+           _tmp.type = dir_ptr->d_type;
+           _tmp.mode = (mode == 0) ? buf.st_mode : ((buf.st_mode & S_IFMT) | mode);
+           _tmp.major = major(buf.st_rdev);
+           _tmp.minor = minor(buf.st_rdev);
+           _devices.push_back(_tmp);
+       }
+       if(dir_ptr->d_type == DT_DIR && recursive)
+           ParseDevicesInFolder(folder + "/" + std::string(dir_ptr->d_name), recursive, mode);
+    }
+
+}
+
+void ColdbootOpt::ParseDevicesInFolder() {
+    Json::Value device_in_folder_json = jsonroot["DevicesInFolder"];
+    for(unsigned int index = 0; index < device_in_folder_json.size(); index ++)
+        ParseDevicesInFolder(device_in_folder_json[index]["path"].asString(), device_in_folder_json[index]["recursive"].asBool(), \
+                              device_in_folder_json[index].get("mode", 0).asInt());
+
+}
+
+void ColdbootOpt::ParseInputDeviceInfo() {
+
+    DeviceInfo input_device_info;
+    std::ostringstream tmp;
+    std::string full_sys_path;
+    std::string full_sys_dev_path;
+    std::string device_number_str;
+    DIR *dir = NULL;
+    struct dirent *dir_ptr = NULL;
+    bool find_matched = false;
+
+    Json::Value input_device_json = jsonroot["InputDevices"];
+    std::string config_path = input_device_json["configpath"].asString();
+    std::string config_path1 = input_device_json["configpath1"].asString();
+    std::string pattern_str = input_device_json["pattern"].asString();
+    input_device_info.mode = input_device_json["mode"].asInt();
+    input_device_info.type = d_mapDeviceType[input_device_json["type"].asString()];
+
+    // Read full config path
+    if(input_device_json["alignwithid"].asBool())
+        config_path.append(std::to_string(container_id));
+
+    // Read content of config file
+    std::ifstream filestr(config_path, std::ios::binary);
+    std::ifstream filestr1(config_path1, std::ios::binary);
+    // Read all content
+    if(filestr.is_open())
+        tmp << filestr.rdbuf();
+    else if(filestr1.is_open())
+        tmp << filestr1.rdbuf();
+    else
+        return;
+    // Fill with /sys prefix
+    full_sys_path = "/sys" + tmp.str();
+    filestr.close();
+    filestr1.close();
+    tmp.str("");
+    tmp.clear();
+
+    // Remove the '\n' of the end
+    full_sys_path = full_sys_path.substr(0, full_sys_path.find_last_not_of(" \n") + 1);
+    if((dir=opendir(full_sys_path.c_str())) == NULL)
+        return;
+
+    while((dir_ptr=readdir(dir)) != NULL) {
+        if(strcmp(dir_ptr->d_name, ".") == 0 || strcmp(dir_ptr->d_name, "..") == 0)
+            continue;
+        if(strstr(dir_ptr->d_name, pattern_str.c_str()) && strcmp(dir_ptr->d_name, "uevent") != 0) {
+            find_matched = true;
+            full_sys_dev_path = full_sys_path + "/" + std::string(dir_ptr->d_name) + "/dev";
+            input_device_info.dev_path = input_device_json["devpath"].asString() + std::string(dir_ptr->d_name);
+        }
+    }
+
+    // If no match found, return
+    if(!find_matched)
+        return;
+    // Read major/minor number
+    std::ifstream dev_num_fstream(full_sys_dev_path, std::ios::binary);
+    if( !dev_num_fstream.is_open() )
+        return;
+
+    tmp << dev_num_fstream.rdbuf();
+    device_number_str = tmp.str();
+    dev_num_fstream.close();
+
+    // Remove the '\n' of the end
+    device_number_str = device_number_str.substr(0, device_number_str.find_last_not_of(" \n") + 1);
+    input_device_info.major = stoi(device_number_str.substr(0, device_number_str.find(':')));
+    input_device_info.minor = stoi(device_number_str.substr(device_number_str.find(':') + 1));
+
+    _devices.push_back(input_device_info);
+}
+
+
+// Tricky solution to create dynamic device due to various pattern
+// Currently, only need to create input device
+void ColdbootOpt::ParseDynamicDeviceInfo() {
+
+    ParseInputDeviceInfo();
+    // Todo: Add more functions to add different device for containers.
+}
+
+void ColdbootOpt::UseHostDevNumber(DeviceInfo &device) {
+
+    struct stat st_buff;
+    if (stat(device.dev_path.c_str(), &st_buff) != 0)
+        return;
+
+    device.major = major(st_buff.st_rdev);
+    device.minor = minor(st_buff.st_rdev);
+}
+
+void ColdbootOpt::RemountDev() {
+    // Remount dev
+    mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755");
+    // Create needed folder
+    mkdir("/dev/pts", 0755);
+    mkdir("/dev/socket", 0755);
+    mkdir("/dev/input", 0755);
+    mkdir("/dev/net", 0755);
+    mount("devpts", "/dev/pts", "devpts", 0, NULL);
+
+    // Create folder from JSON file
+    // For the permission of folder, hard code for 0755 now
+    for(const auto& ele : _subfolders)
+        mkdir(ele.c_str(), 0755);
+}
+
+void ColdbootOpt::CreateDevices() {
+
+    ParseCommonDeviceInfo();
+    ParseDynamicDeviceInfo();
+    ParseDevicesInFolder();
+    RemountDev();
+    for (const auto& ele : _devices) {
+        if (mknod(ele.dev_path.c_str(), ele.mode | ele.type, makedev(ele.major, ele.minor)) != 0 &&  errno != EEXIST)
+            continue;
+        chmod(ele.dev_path.c_str(), ele.mode);
+    }
+    _devices.clear();
+    close(open(COLDBOOT_DONE, O_WRONLY|O_CREAT|O_CLOEXEC, 0000));
+
+}
+
+int find_container_id(int count, char **values)
+{
+    for(int i = 0; i < count; ++i) {
+        if(!strcmp(values[i], "sys.container.id")) {
+            if(i < count - 1) {
+                return std::stoi(values[i+1]);
+            }
+        }
+    }
+
+    return 0;
+}
+
+#define BINDERFS_MAX_NAME 255
+struct binderfs_device {
+       char name[BINDERFS_MAX_NAME + 1];
+       __u32 major;
+       __u32 minor;
+};
+#define BINDER_CTL_ADD _IOWR('b', 1, struct binderfs_device)
+static void create_binder_devices() {
+    int fd = 0, ret = 0, index = 0;
+    char const *device_names[] = {"binder", "vndbinder", "hwbinder"};
+
+    LOG(INFO) << "create_binder_devices";
+    if(mkdir("/dev/binderfs", 0755) && errno != EEXIST) {
+        PLOG(FATAL) << "Failed to create binderfs folder, error:";
+        return;
+    }
+    if (access("/dev/binderfs/binder-control", F_OK) != 0) {
+        if(mount("binder", "/dev/binderfs", "binder", 0, NULL)) {
+            PLOG(FATAL) << "Failed to mount binderfs, error:";
+            return;
+        }
+    }
+    LOG(INFO) << "binderfs is mounted at: /dev/binderfs";
+
+    fd = open("/dev/binderfs/binder-control", O_RDONLY | O_CLOEXEC);
+    if (fd < 0) {
+        PLOG(FATAL) << "Failed to open binder-control device, error:";
+        return;
+    }
+
+    for (index = 0; index < (int)(sizeof(device_names)/sizeof(device_names[0])); index++) {
+        struct binderfs_device binder_device = {.name = {'\0'}, .major = 0, .minor = 0 };
+        sprintf(binder_device.name, "%s", device_names[index]);
+        ret = ioctl(fd, BINDER_CTL_ADD, &binder_device);
+
+        if (ret < 0)
+            PLOG(INFO) << "Failed to allocate new binder device, error:";
+        else
+            PLOG(INFO) << "new binder device created:" << binder_device.name;
+    }
+
+    close(fd);
+}
+
+void coldbootopt_main(const std::string& jsonfile, int id) {
+    ColdbootOpt coldboot_opt(jsonfile, id);
+    coldboot_opt.CreateDevices();
+    create_binder_devices();
+}
+
+} //namespace init
+} //namespace android
diff --git a/init/coldboot_opt.h b/init/coldboot_opt.h
new file mode 100644
index 000000000..eba54049f
--- /dev/null
+++ b/init/coldboot_opt.h
@@ -0,0 +1,13 @@
+#ifndef INIT_COLDBOOT_OPT_H
+#define INIT_COLDBOOT_OPT_H
+
+namespace android {
+namespace init {
+
+int find_container_id(int count, char **values);
+int coldbootopt_main(const std::string& jsonfile, int id);
+
+}  // namespace init
+}  // namespace android
+
+#endif
diff --git a/init/first_stage_init.cpp b/init/first_stage_init.cpp
index b0c78bff1..c237f027a 100644
--- a/init/first_stage_init.cpp
+++ b/init/first_stage_init.cpp
@@ -44,6 +44,10 @@
 #include "switch_root.h"
 #include "util.h"
 
+#ifdef _ANDROID_AS_GUEST_
+#include "coldboot_opt.h"
+#endif
+
 using android::base::boot_clock;
 
 using namespace std::literals;
@@ -190,10 +194,14 @@ int FirstStageMain(int argc, char** argv) {
     CHECKCALL(setenv("PATH", _PATH_DEFPATH, 1));
     // Get the basic filesystem setup we need put together in the initramdisk
     // on / and then we'll let the rc file figure out the rest.
+#ifndef _ANDROID_AS_GUEST_
     CHECKCALL(mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755"));
     CHECKCALL(mkdir("/dev/pts", 0755));
     CHECKCALL(mkdir("/dev/socket", 0755));
     CHECKCALL(mount("devpts", "/dev/pts", "devpts", 0, NULL));
+#else
+    coldbootopt_main("/coldboot_dev.json", find_container_id(argc, argv));
+#endif
 #define MAKE_STR(x) __STRING(x)
     CHECKCALL(mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC)));
 #undef MAKE_STR
@@ -215,9 +223,11 @@ int FirstStageMain(int argc, char** argv) {
     CHECKCALL(mknod("/dev/random", S_IFCHR | 0666, makedev(1, 8)));
     CHECKCALL(mknod("/dev/urandom", S_IFCHR | 0666, makedev(1, 9)));
 
+#ifndef _ANDROID_AS_GUEST_
     // This is needed for log wrapper, which gets called before ueventd runs.
     CHECKCALL(mknod("/dev/ptmx", S_IFCHR | 0666, makedev(5, 2)));
     CHECKCALL(mknod("/dev/null", S_IFCHR | 0666, makedev(1, 3)));
+#endif
 
     // These below mounts are done in first stage init so that first stage mount can mount
     // subdirectories of /mnt/{vendor,product}/.  Other mounts, not required by first stage mount,
-- 
2.39.0

